<br><br><br><br><br><br><br><br><br><br><br>
</div>
</div>
<div class="footer row" style="background-color:blue;">  
    <table border="1" width="80%">
    <tr><th>Previous</th><th>Now Playing</th><th>Next</th></tr>
	<tr><td><div id="prev_text"></div></td><td><div id="play_text"></div></td><td><div id="next_text"></div></td></tr>  
	</table> 
    <input type="button" value="PREV" id="prevbtn"> <button id="ppbtn" type="button">IDLE</button> 
    <input id="curtime" type="text" name="curseconds" value="0">
    <input type="range" step="any" id="seekbar" value="0">
    <input id="endtime" type="text" name="endseconds" value="0">
    <input type="button" value="NEXT" id="nextbtn">
	
    <iframe src="static/250ms_silence.mp3" allow="autoplay" id="audio" style="display:none"></iframe>
</div>

<script type="text/javascript">
  
    function GetItemPath(elm) {
            var els = [];
            var lastitem;
            do {                        
                var elmtemp = elm;
                while(elmtemp.firstChild)
                {
                    elmtemp = elmtemp.firstChild;
                }
                if(elmtemp.textContent != lastitem) {                    
                    lastitem = elmtemp.textContent;                   
                    els.unshift(elmtemp.textContent);
                }                       
                
                elm = elm.parentNode;                        
            }while(elm.id != 'musicdb');
            var path = '';
            //console.log(els);
            els.forEach(function(part) {
                path += part + '/';
            });
            path = path.slice(0, -1);
            return path;
        }        

        function GetChildTracks(path, nnodes) {
            path += '/';
            var nodes = [];        
            for(var i = nnodes.length; i--; nodes.unshift(nnodes[i]));       
            var tracks = [];            
            nodes.splice(0, 1);
            nodes.forEach( function ( node) {
                if(node.childNodes.length == 1) {
                    var newnodes = node.childNodes[0].childNodes[0].childNodes[0].childNodes;
                    var nodearr = [];
                    for(var i = newnodes.length; i--; nodearr.unshift(newnodes[i])); 
                    var felm = nodearr[0].childNodes[0].textContent;       
                    var ttracks = GetChildTracks(path + felm, nodearr);
                    tracks = tracks.concat(ttracks);                                 
                }
                else {                    
                    tracks.push(path + node.childNodes[0].childNodes[0].textContent);
                }                
                        
            });            
            return tracks;
        }    
        
        var dbarea = document.getElementById('musicdb');
        dbarea.addEventListener('click', function(e) {
            if(e.target !== e.currentTarget) {
                console.log(e.target + ' clicked with text ' + e.target.textContent);
                if(e.target.textContent == 'Queue') {
                    path = GetItemPath(e.target.parentNode.parentNode);                    
                    console.log("Queuing - " + path);
                    if(e.target.parentNode.tagName == 'TD') {
                        queueTrack(path);
                    }
                    else {                                  
                        var tracks = GetChildTracks(path, e.target.parentNode.parentNode.parentNode.childNodes);                        
                        queueTracks(tracks);                        
                    }
                    e.preventDefault();
                }
                else if(e.target.textContent == 'Play') {
                    path = GetItemPath(e.target.parentNode.parentNode);                    
                    console.log("Playing - " + path);
                    if(e.target.parentNode.tagName == 'TD') {
                        playTrackNow(path);
                    }
                    else {
                        var tracks = GetChildTracks(path, e.target.parentNode.parentNode.parentNode.childNodes);
                        playTracksNow(tracks);                    
                    }
                    e.preventDefault();
                }                
            }
            e.stopPropagation();        
        });
        
     
    const urlParams = new URLSearchParams(window.location.search);
    const MAX_SAMPLE_RATE = urlParams.get('max_sample_rate');
    const BITDEPTH = urlParams.get('bitdepth');
    const USESEGMENTS = urlParams.get('segments');
    var PTrackUrlParams;
    
    function AddPTrack(track) {
        PTrackUrlParams.append('ptrack', track);            
        window.history.replaceState('playlist', 'Title', 'music_gapless?' + PTrackUrlParams.toString());      
    }
    
    function queueTrack(track) {
        _queueTrack(track);
        AddPTrack(track);
    }
    
   
    
    function queueTracks(tracks) {
        tracks.forEach(function(track) {
            _queueTrack(track);
            PTrackUrlParams.append('ptrack', track);  
        });                      
        window.history.replaceState('playlist', 'Title', 'music_gapless?' + PTrackUrlParams.toString());                        
    }
    
    
Number.prototype.toHHMMSS = function () {
    var sec_num = Math.floor(this); //parseInt(this, 10); // don't forget the second param
    var hours   = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    var seconds = sec_num - (hours * 3600) - (minutes * 60);
    var str;
    if(hours > 0) {
        if (hours   < 10) {hours   = "0"+hours;}
        str = hours+':'
    }
    else {
        str = '';
    }
    //if (minutes < 10) {minutes = "0"+minutes;}
    if (seconds < 10) {seconds = "0"+seconds;}
    return  str+minutes+':'+seconds;   
}
    
    function SetCurtimeText(seconds) {
        var curtime = document.getElementById("curtime");    
        curtime.value = seconds.toHHMMSS() ;
    }
    function SetEndtimeText(seconds) {
        var endtime = document.getElementById("endtime");
        endtime.value = seconds.toHHMMSS() ;
    }
    
    function SetNextText(text) {
        document.getElementById('next_text').innerHTML = '<span>' + text + '</span>';    
    }
    
    function SetPrevText(text) {
        document.getElementById('prev_text').innerHTML = '<span>' + text + '</span>';    
    }
    
    function SetPlayText(text) {    
        document.getElementById('play_text').innerHTML = '<span>' + text + '</span>';
    }
    
    function CreateAudioContext() {
        return (window.hasWebKit) ? new webkitAudioContext() : (typeof AudioContext != "undefined") ? new AudioContext() : null;    
    }
        
   
    var MainAudioContext = CreateAudioContext();
    const BUFFER_MS = 300; //in MS
    const BUFFER_S = (BUFFER_MS/1000);
    var State = 'IDLE';
    var CurrentTrack = 0;
    var Tracks = [];  
    var DLImmediately = true;   
    var TickTimer = null;
    var StartTimer = null;
    var NextBufferTime; 
    var request = null;
    
    function isLoading() {
        return (State == 'IDLE') && (Tracks[CurrentTrack] && Tracks[CurrentTrack].downloading);     
    }
    
    function playTrackNow(track) {
		if((State == 'IDLE')&& (!isLoading())) {
			queueTrack(track);
		}
		else { 
            var toadd = {trackname: track};         
            Tracks.splice(CurrentTrack+1, 0,  toadd);           
            switchTrackNow(1);
            BuildPTrack();                
		}
    }
    
    function playTracksNow(tracks) {
        if((State == 'IDLE')&& (!isLoading())) {
            queueTracks(tracks);                
        }
        else {
            var i = 1;
            tracks.forEach(function(track) {
                Tracks.splice(CurrentTrack+i, 0,  {trackname: track});     
                i++;                    
            });
            switchTrackNow(1);
            BuildPTrack();
        }        
    }
    
    function UpdateState(newState) {
        console.log('State ' + State + ' -> ' + newState);
        State = newState;        
    }
    
    function onTrackStart() {
        StartTimer = null;
        
        if(Tracks[CurrentTrack - 1]) {
            SetPrevText(Tracks[CurrentTrack-1].trackname);
        }
        
        
        if( Tracks[CurrentTrack].source) {
            SetPlayText(Tracks[CurrentTrack].trackname);        
            var seekbar = document.getElementById("seekbar");
            seekbar.min = 0;       
            seekbar.max = Tracks[CurrentTrack].duration;        
            Tracks[CurrentTrack].source.onended = onTrackEnd;
            console.log(Tracks[CurrentTrack].trackname + ' (' + CurrentTrack + ') should now be playing');  
            if(! Tracks[CurrentTrack+1]) {
                SetNextText('');
                DLImmediately = true;
                console.log('DLImmediately set to true');
                return;
            }
            SetNextText(Tracks[CurrentTrack+1].trackname);
            if(Tracks[CurrentTrack+1].buf){
                console.log('buf present, aqueue');
                aqueue(Tracks[CurrentTrack+1]);
            }
            else if(! Tracks[CurrentTrack+1].downloading) {
                downloadAndQueue(Tracks[CurrentTrack+1]);
            }
            else {
                //next track is already downloading               
                if(Tracks[CurrentTrack+1].timeskipped != 0) {
                    console.log('timeskipped value: ' + Tracks[CurrentTrack+1].timeskipped);
                    alert('timeskipped not cleared ' + CurrentTrack+1 + ' ' + Tracks[CurrentTrack+1]);                    
                    Tracks[CurrentTrack+1].timeskipped = 0;
                }
                console.log('next track is already downloading?');               
            }
        }
        else if(Tracks[CurrentTrack].curseg && (Tracks[CurrentTrack].curseg >= 1)) {
            SetPlayText(Tracks[CurrentTrack].trackname);        
            var seekbar = document.getElementById("seekbar");
            seekbar.min = 0;       
            seekbar.max = Tracks[CurrentTrack].duration;        
           
            console.log(Tracks[CurrentTrack].trackname + ' (' + CurrentTrack + ') should now be playing with duration ' + Tracks[CurrentTrack].duration); 
            if(! Tracks[CurrentTrack+1]) {
                SetNextText(''); 
                if(Tracks[CurrentTrack].numsegments == Tracks[CurrentTrack].curseg) {
                    DLImmediately = true;
                }                    
                return;
            }
            SetNextText(Tracks[CurrentTrack+1].trackname);   
            if(Tracks[CurrentTrack].numsegments == Tracks[CurrentTrack].curseg) {
                if(! Tracks[CurrentTrack+1].downloading) {
                    downloadAndQueue(Tracks[CurrentTrack+1]);
                }           
            }           
        }
        else if(Tracks[CurrentTrack].downloading) {
            UpdateState('IDLE');        
        }
        else {
            alert('still going here somehow CurrentTrack doesnt have a source and isnt downloading');                    
        }
    }
    
    function clearTrackSource(track) {
        if(track.source) {
            track.source.onended = function(){};                
            track.source.stop();  
            track.source.disconnect();
            track.source = null;
        }
        else if(track.sources){
            track.sources.forEach(function(source) {
                if(! source) return;
                source.onended = function(){};    
                source.stop();
                source.disconnect();                              
            });
            track.sources = [];
            track.curseg = null;
            Tracks[CurrentTrack].SKIPNOW = null;            
        }       
    }
    
    function onTrackEnd(event) {
        var time = MainAudioContext.currentTime - Tracks[CurrentTrack].astart  +  Tracks[CurrentTrack].timeskipped;          
        console.log('track time: ' + time + ' duration ' + Tracks[CurrentTrack].duration);
        
        //if there's still a start timer, we likely seeked to the end
        if(StartTimer) {        
            console.log('starttimer present, running it now instead');
            clearTimeout(StartTimer);
            onTrackStart();
            play();
        }
      
        // free memory
        clearTrackSource(Tracks[CurrentTrack]); 
        Tracks[CurrentTrack].buf = null;
        Tracks[CurrentTrack].bufs = null;
        Tracks[CurrentTrack].timeskipped = 0;  
        
        CurrentTrack++;        
        
        if(! Tracks[CurrentTrack]) {
            SetPrevText(Tracks[CurrentTrack-1].trackname);
            SetPlayText('');
            console.log('reached end of queue, stopping');
            stop();
            return;
        }        
        onTrackStart() ;          
    }   
    
    
    function aqueue(track) {
        var source = MainAudioContext.createBufferSource();                    
		source.connect(MainAudioContext.destination);
		source.buffer = track.buf;                      
        track.astart = NextBufferTime;
        track.duration = source.buffer.duration;          
        track.source = source;
        console.log('Scheduled ' + track.trackname + ' for ' + NextBufferTime);  
        track.source.start(NextBufferTime, track.timeskipped);                
        var timeleft = track.duration - track.timeskipped;
        NextBufferTime += timeleft;         
    }
    
    function aqueueSeg(track, segment) {
        var source = MainAudioContext.createBufferSource();                    
		source.connect(MainAudioContext.destination);
		source.buffer = segment;        
        if(track.curseg == 1) {        
            track.astart = NextBufferTime;                        
            console.log('Scheduled ' + track.trackname + ' for ' + NextBufferTime); 
        }
        else {
            console.log('Scheduled ' + track.trackname + ' for ' + NextBufferTime + 'part: ' + track.curseg); 
            
            // after the last segment is downloaded, apply the end hook
            if(track.curseg == track.numsegments) {
                source.onended = onTrackEnd; 
                console.log('last segment dled');                                
            }
            else if(track.numsegments == 0) {
                console.log('notqueuing track.numsegments is 0');
                return;
            }
            else
            {
                console.log('curseg ' + track.curseg + ' numsegments ' + track.numsegments);
            }
        }
        var starttime = 0;
        if(Tracks[CurrentTrack].SKIPNOW) {
            Tracks[CurrentTrack].SKIPNOW = null;
            var segmenttimeskipped = (track.timeskipped % track.maxsegduration);       
            console.log('segment timeskipped ' + segmenttimeskipped); 
            starttime += segmenttimeskipped;
            track.astart = NextBufferTime;
        }        
               
        source.start(NextBufferTime, starttime);        
        var timeleft = source.buffer.duration - starttime;         
        NextBufferTime += timeleft;
        track.bufs[track.curseg - 1] = segment;
        track.sources[track.curseg - 1] = source;        
    }    
    
    
    function OnStartTimer() {
        StartTimer = setTimeout( function() {
           onTrackStart();
           play(); 
        }, BUFFER_MS);    
    }    
    
    function downloadAndQueue(track) {          
                         
        request = new XMLHttpRequest();
        var toDL = geturl(track.trackname);
        if(USESEGMENTS) {
            track.curseg = track.curseg || 1;
            track.sources = track.sources || [];
            track.bufs = track.bufs || [];
            toDL += '&part=' + track.curseg;
            track.timeskipped = track.timeskipped || 0;
        }
        else {
            track.timeskipped = 0;        
        }
        track.busy = true;
        track.downloading = true;
        request.track = track;
		request.open('get', toDL, true);
		request.responseType = 'arraybuffer';       
		track.mission = function () {           
            if(USESEGMENTS) {
                track.duration =  Number(request.getResponseHeader('X-MHFS-TRACKDURATION')); 
                track.numsegments = Number(request.getResponseHeader('X-MHFS-NUMSEGMENTS'));
                track.maxsegduration = Number(request.getResponseHeader('X-MHFS-MAXSEGDURATION')); 
                if(track.numsegments == 0) console.log('track.numsegments is 0');                              
            }
            track.decoding = true;      
            track.mission =  function(incomingBuffer) {                
                track.decoding = false;
                track.busy = false;                
                request = null;
                track.mission = null;                             
                if(! incomingBuffer) {
                    console.log('incomingBuffer is null, decode failed');
                    return;
                }
                // setup a callback to update the UI, if we aren't running, normally we'll update on source.onended
                if((State == 'IDLE')) {
                    if(USESEGMENTS && (NextBufferTime > MainAudioContext.currentTime)) {
                         console.log('nextbuffertime not changed ' + NextBufferTime);
                    }
                    else {
                        console.log('nextbuffertime changed');
                        NextBufferTime = MainAudioContext.currentTime + BUFFER_S;                       
                        OnStartTimer();
                    }
                }              
                
                // queue the decoded data
                if(USESEGMENTS) {
                    console.log('downloaded ' + track.trackname + ' part ' + track.curseg);
                    aqueueSeg(track, incomingBuffer);
                    if(track.curseg == track.numsegments) {                        
                        if(! Tracks[CurrentTrack+1] || Tracks[CurrentTrack+1].curseg) {
                            DLImmediately = true;
                            return;
                        }                            
                        downloadAndQueue(Tracks[CurrentTrack+1]);
                        return;
                    }
                    track.curseg++;
                    downloadAndQueue(track);                             
                }
                else{                                   
                    track.buf = incomingBuffer;                               
                    aqueue(track);                
                    console.log('downloaded ' + track.trackname);
                }                           
			};

            MainAudioContext.decodeAudioData(request.response, function(incomingBuffer) {
                track.decoding = false;
                track.busy = false;   
                track.mission(incomingBuffer);
            }, function() {
                track.decoding = false;
                track.busy = false;   
                track.mission();
            });
            
		};

        request.onload = function () {
            track.downloading = false;
            track.decoding = false;
            track.mission();
        };
        request.onabort = function() {
            console.log('req aborted ' + track.trackname);
            track.downloading = false;
            track.decoding = false;
            track.mission();      
        };
        request.onerror = function() {
            console.log('req error ' + track.trackname);
            track.downloading = false;
            track.decoding = false;
            track.mission();         
        }; 

		request.send();    
    }   
    
    function geturl(trackname) {
        var url = 'music_dl?name=' +  encodeURIComponent(trackname);
        if(MAX_SAMPLE_RATE) url += '&max_sample_rate=' + MAX_SAMPLE_RATE;
        if(BITDEPTH) url += '&bitdepth=' + BITDEPTH;           
        url += '&gapless=1&gdriveforce=1';
        return url;
    }
      
    function _queueTrack(_trackname) {               
        var track = {trackname: _trackname};               
        Tracks.push(track);
        if(DLImmediately) {
            DLImmediately = false;
            console.log('downloading immediately');                        
            downloadAndQueue(track);                    
        }
        else {
            console.log('queued track for later dl');            
        } 
        if((CurrentTrack+1) == (Tracks.length-1)) {
            SetNextText(Tracks[Tracks.length-1].trackname);
        }
        else if(CurrentTrack == (Tracks.length -1)) {
            SetPlayText(Tracks[CurrentTrack].trackname + ' {![LOADING]!}');
        }        
    }
    
    function play() {
        UpdateState('PLAY');
        var ppbtn = document.getElementById("ppbtn");
        if(! TickTimer) {
            Tick(27);
        }            
        ppbtn.textContent = 'PAUSE';
    }
    
    function resume() {        
        MainAudioContext.resume();       
        play();        
    }
    
    
    function pause() {           
        clearTimeout(TickTimer);
        clearTimeout(StartTimer);  
        TickTimer = null;
        StartTimer = null;        
    }
    
    function stop() {              
        SetCurtimeText(0);
        seekbar.value = 0;
        SetEndtimeText(0);       
        UpdateState('IDLE');        
        pause();
        var ppbtn = document.getElementById("ppbtn"); 
        ppbtn.textContent = 'IDLE';
    }
    

    var SBAR_UPDATING = 0;    
    function Tick(tickMS) {
        //console.log('tick event');
        if(! Tracks[CurrentTrack]) {
            TickTimer = null;
            console.log('TickTimer null');
            return;        
        }
        else if(Tracks[CurrentTrack].astart <= MainAudioContext.currentTime) { 
            var seekbar = document.getElementById("seekbar");        
            //console.log('sbar value ' + seekbar.value);
            if(SBAR_UPDATING) {
                console.log('Not updating SBAR, SBAR_UPDATING');
                return;
            }          
            //console.log('MAC ' + MainAudioContext.currentTime + ' astart ' + Tracks[CurrentTrack].astart +  ' timeskipped ' + Tracks[CurrentTrack].timeskipped);            
            var time = MainAudioContext.currentTime - Tracks[CurrentTrack].astart  +  Tracks[CurrentTrack].timeskipped;   
            SetCurtimeText(time);             
            seekbar.value = time;        
            SetEndtimeText(Tracks[CurrentTrack].duration);                       
            //console.log(Tracks[CurrentTrack].trackname + ' (' + CurrentTrack + '): updating progress');                     
        }
        else {            
            console.log(Tracks[CurrentTrack].trackname + ' (' + CurrentTrack + '): not updating seekbar');
        }
 
        TickTimer =  setTimeout(function () { Tick(tickMS); }, tickMS);       
    }
    
    function track_getTimeskippedSegment(track) {
        var segment = Math.floor(track.timeskipped / track.maxsegduration) + 1; //1 based
        console.log('timeskipped ' + track.timeskipped + 'maxsegduration ' + track.maxsegduration + ' segment ' + segment);
        return segment;
    }

    function switchTrackNow(direction) {
        //anything here is going to take time so stop the ticktimer
        pause();
        
        //stop the current and next track if they exist       
        if(Tracks[CurrentTrack]) clearTrackSource(Tracks[CurrentTrack]);
        if(Tracks[CurrentTrack+1]) clearTrackSource(Tracks[CurrentTrack+1]);
        
        if(USESEGMENTS) {            
            NextBufferTime = MainAudioContext.currentTime; //bad hack                      
        }           
        
        function setTracks(track) {
            NextBufferTime = MainAudioContext.currentTime + BUFFER_S;                        
            aqueue(track);
            track.source.onended = onTrackEnd;                       
        }
        
        // if the desired current track is the same we don't need to download again (seeking)
        if(direction == 0) {
            console.log('seek operation');
            if(! USESEGMENTS) {
                setTracks(Tracks[CurrentTrack]);
            }
            else {
                var desiredseg = track_getTimeskippedSegment(Tracks[CurrentTrack]);
                Tracks[CurrentTrack].curseg = desiredseg;
                Tracks[CurrentTrack].SKIPNOW = 1;
                //if(! Tracks[CurrentTrack].bufs[desiredseg-1]) {
                if(1) {
                    console.log('segment not available, downloading ' + desiredseg);
                    var toDo = function() {
                        UpdateState('IDLE');
                        downloadAndQueue(Tracks[CurrentTrack]);
                    };
                    if(request){                
                        request.track.mission = toDo;
                        request.abort();                      
                    } 
                    else {
                        toDo();
                    }                    
                    return;                    
                }
                NextBufferTime = MainAudioContext.currentTime + BUFFER_S;                        
                aqueueSeg(Tracks[CurrentTrack], Tracks[CurrentTrack].bufs[desiredseg-1]);                                
            }
            OnStartTimer();
            return;
            
        }
        //free memory
        else if(Tracks[CurrentTrack]) {
            Tracks[CurrentTrack].timeskipped = 0;            
            Tracks[CurrentTrack].buf = null;
            Tracks[CurrentTrack].bufs = null;
        }
        
        // abort download, if the desired track is not downloading
        var dtrack = Tracks[CurrentTrack+direction];
        if(dtrack && (!dtrack.downloading)) {                    
            if(request){                
                request.track.mission = function() {                    
                };
                request.abort();                
            }            
        } 
            
       
        // NEXT
        if(direction == 1) {           
            //if its downloaded, requeue it 
            if(Tracks[CurrentTrack+1].buf) {
                setTracks(Tracks[CurrentTrack+1]); 
                OnStartTimer();               
            }
            // if it is downloading, let the downloader start as if we are idle
            else if(Tracks[CurrentTrack+1].downloading) {
                UpdateState('IDLE');           
            }
            // othewise download it now
            else {                         
                UpdateState('IDLE'); 
                downloadAndQueue(Tracks[CurrentTrack+1]); 
            }
            CurrentTrack++;
        }
        else if(direction == -1) {           
            DLImmediately = false;           
            UpdateState('IDLE'); 
            downloadAndQueue(Tracks[CurrentTrack-1]); 
            CurrentTrack--;            
        }
        
        //update the viewable text
        
        if(Tracks[CurrentTrack-1]) {
            SetPrevText(Tracks[CurrentTrack-1].trackname);
        }
        else {
            SetPrevText('');        
        }
        if(Tracks[CurrentTrack]) {
            SetPlayText(Tracks[CurrentTrack].trackname + ' {![LOADING]!}');                                                
            var current_time = Tracks[CurrentTrack].timeskipped || 0;
            SetCurtimeText(current_time);
            var seekbar = document.getElementById("seekbar");  
            seekbar.value = current_time;            
            SetEndtimeText(Tracks[CurrentTrack].duration || 0);             
        }
        if(Tracks[CurrentTrack+1]) {
            SetNextText(Tracks[CurrentTrack+1].trackname);            
        }
        else {
           SetNextText('');
        }        
    }  
    
    window.onload = function() {        
        var prevbtn = document.getElementById("prevbtn");
        var sktxt = document.getElementById("seekfield");
        var seekbar = document.getElementById("seekbar");
        var ppbtn = document.getElementById("ppbtn");        
        
        ppbtn.addEventListener('click', function (e) {            
            if(State == 'PLAY') {                              
                MainAudioContext.suspend();                
                UpdateState('PAUSE'); 
                ppbtn.textContent = 'PLAY';
                pause();                
            }
            else if(State == 'PAUSE') {               
                resume();
            }
            else if(State == 'IDLE') {
                
            }            
        });        
        
        seekbar.addEventListener('mousedown', function(e) {        
            do {            
                if(State == 'PLAY') {                   
                    break;
                }
                if(State == 'PAUSE') break;               
                return;           
            } while(0);    

            console.log('BEGIN SBAR UPDATE');
            SBAR_UPDATING = 1;                    
        });
        
        seekbar.addEventListener('change', function(e) {
            console.log( Tracks[CurrentTrack].trackname + ' (' + CurrentTrack + ') ' + ' seeking to ' + seekbar.value);
            Tracks[CurrentTrack].timeskipped = Number(seekbar.value);           
            switchTrackNow(0);            
            SetCurtimeText( Tracks[CurrentTrack].timeskipped );
            console.log('END SBAR UPDATE');
            SBAR_UPDATING = 0;             
        });
        
        prevbtn.addEventListener('click', function(e) {
            do {            
                if(State == 'PLAY') break;
                else if(State == 'PAUSE') {
                    resume();
                    break;
                }
                else if(State == 'IDLE') {
                    break;                
                }                
                return;           
            } while(0);
            if((CurrentTrack-1) < 0) return;
            switchTrackNow(-1);   
            SetCurtimeText(0);
            if(Tracks[CurrentTrack].duration) SetEndtimeText(Tracks[CurrentTrack].duration);  
            console.log('prevtrack?');            
        });
        
        nextbtn.addEventListener('click', function(e) {
            do {
                if(State == 'PLAY') break;
                else if(State == 'PAUSE') {
                    resume();
                }                
                //return;
            } while(0);
            if(! Tracks[CurrentTrack+1]) return;
            switchTrackNow(1);   
            SetCurtimeText(0);
            if(Tracks[CurrentTrack].duration) SetEndtimeText(Tracks[CurrentTrack].duration);            
        });            
    };
    
     function _BuildPTrack() {
         PTrackUrlParams = new URLSearchParams();
         if(MAX_SAMPLE_RATE) PTrackUrlParams.append('max_sample_rate', MAX_SAMPLE_RATE);
         if(BITDEPTH) PTrackUrlParams.append('bitdepth', BITDEPTH);
         if(USESEGMENTS) PTrackUrlParams.append('segments', USESEGMENTS);
         Tracks.forEach(function(track) {
             PTrackUrlParams.append('ptrack', track.trackname); 
         });                  
     }
        
     function BuildPTrack() {
         _BuildPTrack();
         var urlstring = PTrackUrlParams.toString();
         if(urlstring != '') {
             window.history.replaceState('playlist', 'Title', 'music_gapless?' + urlstring);
         }
     }
        
        _BuildPTrack();        
        var orig_ptracks = urlParams.getAll('ptrack');
        if(orig_ptracks.length > 0) {
            queueTracks(orig_ptracks);
        }
   

    </script>
</body>
